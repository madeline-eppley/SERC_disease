## SERC disease analysis workflow
- I received two disease files from Calli Wise (SERC staff in CDE lab) that contained Dermo and bioeroder data (+ some extras) for the MarineGEO project
- Three years of data (2022, 2023, and 2024) were together in the first file. After the completion of the 2025 data collection (yay!) I was sent a follow-up file with the 2025 data. Now this file has been compiled to have ALL of the data! awesome! however, I am going to keep some residual code from when I merged the 2022-2024 data (which had different column names between sheets) in case I need to re-visit that for any reason.
- This file contains analysis steps in R that I followed to analyze the data, as well as my thoughts/workflow, which are also heavily annotated in the R scripts
- High-quality PDFs of figures are often generated (alongside png uploads in this .md file) and are stored in the /fig folder of this repo.

## Analysis goals
After our first meeting (2025/10/7), Katrina and I decided to focus on answering these intitial 3 questions with the dataset. Here's the analysis plan: 

| Research Question | Statistical Method | Response Variable | Predictor Variables | Visualization |
|-------------------|-------------------|-------------------|---------------------|---------------|
| How does the relationship between Dermo + bioeroder vary across rivers and over time? | GLM | Bioeroder presence or absence | Dermo intensity * river * year | Interaction plot? |
| How many oysters are co-infected and how does co-infection vary across rivers and over time? | Multinomial logistic regression (?, check) | Infection groups (co-infected, single infection, uninfected) | River, year | Venn diagram with all co-infections and stacked bar plot for each river with year on x |
| Do different rivers have different disease prevalences/intensities? | PCA | Matrix of all infections subset by river (includes dermo intensity, bioeroder presence, and co-infection status) | river | PCA with individual oysters = points colored by river and/or heatmaps of infection prevalence by river |

### Step 1: Figure out what's present/absent in the data
The first thing to do is figure out which rivers are represented in our data, and how many data points are available for each year. This will help me make decisions about what data to keep. 

```R
# read in data
rawfile <- "/Users/madelineeppley/Desktop/MarineGeo_OysterData_SevernSouthRhodeWest_2025.11.19.xlsx"
data <- read_excel(rawfile, sheet = "Data") # this is now all years of data together, 485 x 65

colnames(data) # going to rename a few of the data columns to keep my code functionality that I wrote pre-2025 dataset
data <- data %>%
  mutate(
    Score_Rectum = DermoScore_Rectum,
    Count_Rectum = DermoCellCount_Rectum,
    Score_Mantle = DermoScore_Mantle,
    Count_Mantle = DermoCellCount_Mantle)

# 2022 data has some samples from the Rhode river, but we don't have these for 2023, 2024, or 2025
# let's check by making subsets
data_2022 <- data %>% filter(Year == 2022)
data_2023 <- data %>% filter(Year == 2023)
data_2024 <- data %>% filter(Year == 2024)
data_2025 <- data %>% filter(Year == 2025)

sum(grepl("Rhode", data_2022$River)) #30 data points
sum(grepl("Rhode", data_2023$River)) #0 data points
sum(grepl("Rhode", data_2024$River)) #0 data points
sum(grepl("Rhode", data_2025$River)) #0 data points

# now let's take a quick look at how many data points we have per year.
counts_2022 <- as.data.frame(table(data_2022$River))
colnames(counts_2022) <- c("River", "Count")

counts_2023 <- as.data.frame(table(data_2023$River))
colnames(counts_2023) <- c("River", "Count")

counts_2024 <- as.data.frame(table(data_2024$River))
colnames(counts_2024) <- c("River", "Count")

counts_2025 <- as.data.frame(table(data_2025$River))
colnames(counts_2025) <- c("River", "Count")

# let's make one composite figure
p22 <- ggplot(counts_2022, aes(x = River, y = Count)) +
  geom_bar(stat = "identity", fill = "#6baed6") +
  labs(title = "2022",
       x = "River",
       y = "Individuals") +
  theme_minimal()

p23 <- ggplot(counts_2023, aes(x = River, y = Count)) +
  geom_bar(stat = "identity", fill = "#0c2c84") +
  labs(title = "2023",
       x = "River",
       y = "Individuals") +
  theme_minimal()

p24 <- ggplot(counts_2024, aes(x = River, y = Count)) +
  geom_bar(stat = "identity", fill = "#c7e9b4") +
  labs(title = "2024",
       x = "River",
       y = "Individuals") +
  theme_minimal()

p25 <- ggplot(counts_2025, aes(x = River, y = Count)) +
  geom_bar(stat = "identity", fill = "mediumblue") +
  labs(title = "2025",
       x = "River",
       y = "Individuals") +
  theme_minimal()

# arrange plot
(p22 | p23) / (p24 | p25)
```

### Data points per year, per river
The figure generated by the above code script is below. Looks relatively even, but again we don't have any Rhode river data for any year but 2022. 

<img width="1398" height="1185" alt="image" src="https://github.com/user-attachments/assets/212ce7d1-14a7-4ef3-953b-ab42bcd35eff" />

> [!NOTE]
> I am going to get rid of the Rhode data from 2022 since we don't have Rhode data for 2023-2025. we can discuss if there's any value in reporting the data anyway somewhere in the paper! I am also getting rid of the 2021 data.


### Standardizing data columns and resolving missingness, producing bioeroder averages
Before getting the combined dataset, the old data format was pretty messy, where columns had slightly different names year-to-year. However, this has largely been solved! In the above code chunk I did rename some column names using mutate() for efficiency, this was to keep downstream compatibility with the code I had already written before recieving the final data sheet.  

Things remaining to address:
- missingness throughout columns (NAs/blanks)
- I noticed that the 2023 data did not average the bioeroder data, so I will need to calculate those averages.
- During my column filtering above I also saw that the 2022 data has A and B data collectors but not L/R valves, so I duplicated the single value across valves.

Here's how I handled this initial data wrangling: 

```R
### code chunk 2 ###
# first we want to remove the Rhode River data and the 2021 data.
data <- data %>% 
  filter(River != "Rhode")
data <- data %>% 
  filter(Year != "2021")

# first make a function that we can use to get rid of any symbols in the columns. we need everything to be a clean number.
clean_num <- function(x) {
  as.numeric(str_extract(as.character(x), "\\d+\\.?\\d*"))}

# ok now we have an interesting case in the 2022 cliona data where we have Avg_A and Avg_B values, but not Left Valve/Right Valve
# i'm going to fill in the values for L/R valves with the Avg so that the next function step will work. 
data <- data %>%
  mutate(
    Cliona_LeftValve_A = ifelse(Year == 2022, Cliona_Avg_A, Cliona_LeftValve_A),
    Cliona_RightValve_A = ifelse(Year == 2022, Cliona_Avg_A, Cliona_RightValve_A),
    `Cliona_LeftValve_B_%` = ifelse(Year == 2022, Cliona_Avg_B, `Cliona_LeftValve_B_%`),
    `Cliona_RightValve_B_%` = ifelse(Year == 2022, Cliona_Avg_B, `Cliona_RightValve_B_%`))

# calculate bioeroder averages for all years - should work now that we have our boring sponge valves filled
data <- data %>%
  mutate( # first do the boring sponge averages
    Cliona_LeftValve_A_num = clean_num(Cliona_LeftValve_A),
    Cliona_RightValve_A_num = clean_num(Cliona_RightValve_A),
    Cliona_Avg_A = rowMeans(
      cbind(Cliona_LeftValve_A_num, Cliona_RightValve_A_num),
      na.rm = TRUE),
    Cliona_LeftValve_B_num = clean_num(`Cliona_LeftValve_B_%`),
    Cliona_RightValve_B_num = clean_num(`Cliona_RightValve_B_%`),
    Cliona_Avg_B = rowMeans(
      cbind(Cliona_LeftValve_B_num, Cliona_RightValve_B_num),
      na.rm = TRUE),
    # now the polydora averages
    Polydora_LeftValve_A_num = clean_num(Polydora_LeftValve_A),
    Polydora_RightValve_A_num = clean_num(Polydora_RightValve_A),
    Polydora_Average_A = rowMeans(
      cbind(Polydora_LeftValve_A_num, Polydora_RightValve_A_num),
      na.rm = TRUE),
    Polydora_LeftValve_B_num = clean_num(`Polydora_LeftValve_B_%`),
    Polydora_RightValve_B_num = clean_num(`Polydora_RightValve_B_%`),
    Polydora_Average_B = rowMeans(
      cbind(Polydora_LeftValve_B_num, Polydora_RightValve_B_num),
      na.rm = TRUE))

# keep only the new columns that i want
keep_cols <- c("Specimen_ID", "River", "Year", "Year_Collected", "Month_Collected", "Day_Collected",
               "Score_Rectum", "Count_Rectum", "Score_Mantle", "Count_Mantle",
               "Polydora_LeftValve_A", "Polydora_RightValve_A", "Polydora_Average_A",
               "Polydora_LeftValve_B_%", "Polydora_RightValve_B_%", "Polydora_Average_B",
               "Cliona_LeftValve_A", "Cliona_RightValve_A", "Cliona_Avg_A",
               "Cliona_LeftValve_B_%", "Cliona_RightValve_B_%", "Cliona_Avg_B",
               "Length_mm", "Blister_Count_A", "Blister_Count_B")

all_data <- data[, intersect(names(data), keep_cols)]

# summary stats
dim(all_data) #370 x 25 nice, increased from 278 inds in the 2022-2024 only data
table(all_data$River) # just severn, south, west
table(all_data$Year) # 2022-2025 with fairly even distribution across years
```

Also one weird R syntax thing that I just learned is that if a variable ends with % you need to encase the variable name in ``.

### Adding co-infection columns and further data cleaning 
- Now i'm also going to want to combine some columns to make new variables for co-infections (Y/N or sum), infected with dermo only, infected with polydora only, and uninfected.
- There are also some crazy symbols (e.g., >, ~) in the dataset, so I need to get rid of those with clean_num as as.numeric. 

```R
### code chunk 3 ###
# trim any whitespaces around columns (there are some whitespaces, I checked lol)
all_data$River <- trimws(all_data$River)
all_data$Specimen_ID <- trimws(all_data$Specimen_ID)

# now get everything into numeric format
all_data$Length_mm <- as.numeric(as.character(all_data$Length_mm))
all_data$Score_Rectum <- as.numeric(as.character(all_data$Score_Rectum))
all_data$Score_Mantle <- as.numeric(as.character(all_data$Score_Mantle))
all_data$Blister_Count_A <- as.numeric(as.character(all_data$Blister_Count_A))
all_data$Blister_Count_B <- as.numeric(as.character(all_data$Blister_Count_B))

# a little sanity check with the ranges of our new numeric variables
range(all_data$Length_mm, na.rm = TRUE)
quantile(all_data$Score_Rectum, na.rm = TRUE) # just taking a quick peek at the data, looks like rectum is more infected than mantle
quantile(all_data$Score_Mantle, na.rm = TRUE)

# now average the A and B observer values
all_data$Polydora_outside <- (all_data$Polydora_Average_A + all_data$Polydora_Average_B) / 2
all_data$Cliona <- (all_data$Cliona_Avg_A + all_data$Cliona_Avg_B) / 2
all_data$Polydora_blister <- (all_data$Blister_Count_A + all_data$Blister_Count_B) / 2

# remove the old cols
all_data <- all_data %>%
  select(-c(Polydora_LeftValve_A, Polydora_RightValve_A, Polydora_Average_A, Polydora_Average_B,
            `Polydora_LeftValve_B_%`, `Polydora_RightValve_B_%`,
            Cliona_LeftValve_A, Cliona_RightValve_A, `Cliona_LeftValve_B_%`, `Cliona_RightValve_B_%`,
            Blister_Count_A, Blister_Count_B, Count_Rectum, Count_Mantle,
            Cliona_Avg_A, Cliona_Avg_B, Year_Collected))

# summary checks again
summary(all_data)
dim(all_data)

# ok now what i'm noticing is that we have a handful of individuals (anywhere from 1-7 in each col) that still have NAs
# i think the best way to deal with this data is to remove these individuals
# katrina should confirm that we want to do this - i don't think they'll be helpful data points down the line

# create the new infection status col
all_data$dermo_infected <- ifelse(all_data$Score_Rectum > 0, 1, 0)
all_data$polydora_infected <- ifelse(all_data$Polydora_outside > 0, 1, 0)
all_data$cliona_infected <- ifelse(all_data$Cliona > 0, 1, 0)
all_data$n_infections <- all_data$dermo_infected + all_data$polydora_infected + all_data$cliona_infected

# check for inds with NAs
na_infections <- all_data[is.na(all_data$n_infections), ]
nrow(na_infections) # only 8 currently - let's just remove those!

# remove those inds
all_data <- all_data[!is.na(all_data$n_infections), ]
dim(all_data) # now down to 362 inds, this makes sense, it was 370 minus the 8 we just removed 

# ok now make a variable for our co-infected/uninfected/single infections
# i think katrina and I should also talk about this, how do we want to document each possible combination of co-infections?
all_data$infection_group <- ifelse(all_data$n_infections == 0, "Uninfected",
                                   ifelse(all_data$n_infections == 1, "Single", "Co-infected"))
all_data$infection_group <- factor(all_data$infection_group, levels = c("Uninfected", "Single", "Co-infected"))

# ok again more summary info
table(all_data$infection_group) # wow only 1 individual that was completely uninfected! 
table(all_data$River, all_data$infection_group)
table(all_data$Year, all_data$infection_group)

# export the shiny new clean data!
write.csv(all_data, "/Users/madelineeppley/Desktop/marineGEO_oysterdisease/marineGEO_clean2225.csv", row.names = FALSE)
```
Here are the output products from that code chunk

```
> table(all_data$River, all_data$infection_group)
        
         Uninfected Single Co-infected
  Severn          1     32          84
  South           0     29         101
  West            0     21          94
```

```
> table(all_data$Year, all_data$infection_group)
      
       Uninfected Single Co-infected
  2022          0     19          71
  2023          0     10          78
  2024          0     29          70
  2025          1     24          60
```

> [!NOTE]
> Some things to talk about with Katrina: do we like the way that the co-infections are grouped? I think we could get more detailed and categorize by different co-infections (e.g., Dermo-polydora, polydora-cliona, Dermo-cliona) although my instinct from looking at the data is that the vast majority of co-infections will just be Dermo and polydora


> [!NOTE]
> I removed 8 individuals from the data set that had only partial data (missing 1 of polydora, cliona, or dermo data). this isn't a substantial number in the grand scheme of the dataset, and i think it would be more annoying to leave them in and have incomplete data versus keeping them in for the categories that we do have data for them. but if we are committed to keeping all individuals, I can add them back in. our total count of individuals in the dataset right now is 362 :)


### visualizations!!
Now for the exciting stuff - here i'm going to make some basic barplots to get familiarized with the data (improve on the tables above) and then start to address our research questions at the top of the doc (starting with a PCA, Q3). 

```R
### code chunk 4 ###
# visualize infections!!!
infection_counts <- table(all_data$Year, all_data$River, all_data$infection_group)
layout(matrix(c(1, 2, 3, 4), nrow = 1), widths = c(1, 1, 1, 0.4))
par(mar = c(5, 4, 4, 1))
barplot(t(infection_counts[, "Severn", ]), beside = FALSE, col = c("#eff3ff", "#6baed6", "#08519c"),
        main = "Severn", xlab = "Year", ylab = "Count of Oysters")
barplot(t(infection_counts[, "South", ]), beside = FALSE, col = c("#eff3ff", "#6baed6", "#08519c"),
        main = "South", xlab = "Year", ylab = "Count of Oysters")
barplot(t(infection_counts[, "West", ]), beside = FALSE, col = c("#eff3ff", "#6baed6", "#08519c"),
        main = "West", xlab = "Year", ylab = "Count of Oysters")
par(mar = c(0, 0, 0, 0))
plot.new()
legend("left", legend = c("Uninfected", "Single", "Co-infected"), 
       fill = c("#eff3ff", "#6baed6", "#08519c"), bty = "n", cex = 0.9)
par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

Here's the product from the barplot code:

<img width="3450" height="1722" alt="image" src="https://github.com/user-attachments/assets/fa5b5b7a-3e68-4c29-996d-23ee0f581011" />


```R
#pca analysis
# let's include dermo rectum, dermo mantle, polydora outside, cliona, and polydora blister
pca_matrix <- cbind(all_data$Score_Rectum, all_data$Score_Mantle, 
                    all_data$Polydora_outside, all_data$Cliona, all_data$Polydora_blister)
colnames(pca_matrix) <- c("Dermo_Rectum", "Dermo_Mantle", "Polydora", "Cliona", "Blister")

pca_result <- prcomp(pca_matrix, scale. = TRUE, center = TRUE)
summary(pca_result)

#dev.off()
# pca by river
river_colors <- c("Severn" = "#0c2c84", "South" = "#c7e9b4", "West" = "#41b6c4")
year_shapes <- c("2022" = 16, "2023" = 17, "2024" = 15, "2025" = 18)
point_shapes <- year_shapes[as.character(all_data$Year)]
plot(pca_result$x[, 1], pca_result$x[, 2], 
     col = river_colors[all_data$River], 
     pch = point_shapes, cex = 1.5,
     xlab = paste0("PC1 (", round(summary(pca_result)$importance[2,1]*100, 1), "%)"),
     ylab = paste0("PC2 (", round(summary(pca_result)$importance[2,2]*100, 1), "%)"),
     main = "")
legend("topleft", 
       legend = c("Severn", "South", "West", "2022", "2023", "2024", "2025"), 
       col = c(river_colors, "black", "black", "black", "black"), 
       pch = c(16, 16, 16, 16, 17, 15, 18), cex = 0.6)
```

Here's the product from the PCA code: 

<img width="3060" height="1812" alt="image" src="https://github.com/user-attachments/assets/7bf91b4d-b58f-42ed-8198-8d12e4a426f9" />

> [!NOTE]
> I'm maybe seeing a little bit of difference in the West river separated out by PC2. There's one outlier looking point from the Severn river in 2022 as well. We should discuss the variables that went into this PCA (e.g., do we want to have both Dermo Rectum AND Dermo Mantle in the PCA? I also have Polydora outside (% of shell covered) AND polydora blisters (# count of total blisters). 



